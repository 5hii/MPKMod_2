/*subprojects {
    apply plugin: 'java'
}*/

subprojects {
    apply plugin: 'java'

    group = project(":common").$group
    version = project(":common").$version
    archivesBaseName = project(":common").$modBaseName

    configurations {
        library
        implementation.extendsFrom library
    }

    dependencies {
        library 'com.github.JnCrMx:discord-game-sdk4j:v0.5.5'

        library 'com.fasterxml.jackson.core:jackson-core:2.8.8'
        library 'com.fasterxml.jackson.core:jackson-annotations:2.8.8'
        //if changed to newer version gives IllegalArgumentException (no error message) idfk why
        library 'com.fasterxml.jackson.core:jackson-databind:2.8.8'

        testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.1'
        testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.1'

        if (project.name != "common") {
            library project(":common")
        }
    }

    repositories {
        mavenCentral()
        maven { url = "https://jitpack.io" }
        maven {
            name = 'Fabric'
            url = 'https://maven.fabricmc.net/'
        }
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
    }

    test {
        useJUnitPlatform()
    }

    jar {
        manifest {
            attributes([
                    "Specification-Title"     : project(":common").$modBaseName,
                    "Specification-Vendor"    : project(":common").$vendor,
                    "Specification-Version"   : "1", // We are version 1 of ourselves
                    "Implementation-Title"    : project(":common").$modBaseName,
                    "Implementation-Version"  : project(":common").$version,
                    "Implementation-Vendor"   : project(":common").$vendor,
                    "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
            ])
        }

        if (project.name != "common") {
            //destinationDirectory = rootProject.buildDir
            doFirst {
                archiveClassifier = project.name
            }
        }

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        from {
            configurations.library.collect { it.isDirectory() ? it : zipTree(it) }
        }
        from {
            "../LICENSE"
            "${project(":common").compileJava.temporaryDir}${File.separator}classes.txt"
        }
    }

    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(project.properties.getOrDefault("jdkVersion", 17) as int)
        }
    }


    tasks.withType(JavaCompile) {
        int jdkVersion = project.properties.getOrDefault("jdkVersion", 17) as int

        sourceCompatibility = jdkVersion
        targetCompatibility = jdkVersion

        if (jdkVersion >= 9)
            options.release.set(jdkVersion)

        options.encoding = 'UTF-8'
    }

    if (project.name != "common") {
        project.afterEvaluate {
            project.tasks.matching { it.name == "runClient" }.all { Task task ->
                tasks.register("runClient_$project.name") {
                    dependsOn task
                    group "runClient"
                }
            }

            tasks.withType(JavaExec) {
                javaLauncher.set(javaToolchains.launcherFor(java.toolchain))
            }

            remapJar {
                inputFile.set project.jar.archiveFile
                destinationDirectory = rootProject.buildDir
                dependsOn project.jar
                archiveFileName = project.jar.archiveFileName
            }
        }
    }
}
